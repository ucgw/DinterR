--- /home/dinter/csce499/linux-4.19.143/fs/notify/inotify/inotify_fsnotify.c.orig	2020-12-16 11:23:12.842303961 -0600
+++ /home/dinter/csce499/linux-4.19.143/fs/notify/inotify/inotify_fsnotify.c	2020-12-17 17:25:04.253968380 -0600
@@ -64,6 +64,7 @@
 	return event_compare(last_event, event);
 }
 
+/* DinterR Update */
 int inotify_handle_event(struct fsnotify_group *group,
 			 struct inode *inode,
 			 u32 mask, const void *data, int data_type,
@@ -74,6 +75,7 @@
 	struct inotify_inode_mark *i_mark;
 	struct inotify_event_info *event;
 	struct fsnotify_event *fsn_event;
+	struct fsnotify_extra_data *fsn_data;
 	int ret;
 	int len = 0;
 	int alloc_len = sizeof(struct inotify_event_info);
@@ -81,12 +83,26 @@
 	if (WARN_ON(fsnotify_iter_vfsmount_mark(iter_info)))
 		return 0;
 
-	if ((inode_mark->mask & FS_EXCL_UNLINK) &&
-	    (data_type == FSNOTIFY_EVENT_PATH)) {
-		const struct path *path = data;
+        fsn_data = NULL;
+	if (data_type == FSNOTIFY_EVENT_INODE_PLUS) {
+		fsn_data = kmalloc(sizeof(struct fsnotify_extra_data),
+				GFP_KERNEL);
+		if (unlikely(!fsn_data)) {
+			fsnotify_queue_overflow(group);
+			return -ENOMEM;
+                }
+		fsn_data = (struct fsnotify_extra_data*)data;
 
-		if (d_unlinked(path->dentry))
-			return 0;
+		kfree(fsn_data);
+	}
+	else {
+	        if ((inode_mark->mask & FS_EXCL_UNLINK) &&
+	            (data_type == FSNOTIFY_EVENT_PATH)) {
+		        const struct path *path = data;
+
+		        if (d_unlinked(path->dentry))
+			        return 0;
+		}
 	}
 	if (file_name) {
 		len = strlen(file_name);
@@ -118,6 +134,11 @@
 	}
 
 	fsn_event = &event->fse;
+        /* DinterR extra data */
+	if (fsn_data) {
+		fsn_event->extra.count = fsn_data->count;
+		fsn_event->extra.pos = fsn_data->pos;
+	}
 	fsnotify_init_event(fsn_event, inode, mask);
 	event->wd = i_mark->wd;
 	event->sync_cookie = cookie;
